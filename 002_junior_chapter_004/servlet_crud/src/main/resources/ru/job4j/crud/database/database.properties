# Users database storage settings
db.type=postgresql
db.address=//localhost:5432
db.name=test_db
db.user=tester
db.password=password
# Structural changes
sql.structure.createTables=/* Create all needed tables */ BEGIN; CREATE TABLE IF NOT EXISTS countries ( id SERIAL PRIMARY KEY, name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS cities ( id SERIAL PRIMARY KEY, name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS users ( id SERIAL PRIMARY KEY, name TEXT, login TEXT UNIQUE, password TEXT, email TEXT, created TIMESTAMP WITH TIME ZONE, role TEXT, country_id INTEGER REFERENCES countries (id), city_id INTEGER REFERENCES cities (id) ); COMMIT;
sql.structure.dropTables=/* Drop all existing tables */ DO $$ DECLARE brow RECORD; BEGIN FOR brow IN (SELECT 'drop table "' || tablename || '" cascade;' AS table_name FROM pg_tables WHERE schemaname = 'public') LOOP EXECUTE brow.table_name; END LOOP; END; $$
sql.structure.dropFunctions=SELECT pg_temp.f_delfunc('public');
# Create database functions
sql.function.dropFunctions=/* Drop all existing functions */ CREATE OR REPLACE FUNCTION pg_temp.f_delfunc(_sch TEXT) RETURNS VOID AS $func$ DECLARE _sql TEXT; BEGIN SELECT INTO _sql string_agg(format('DROP FUNCTION IF EXISTS %s(%s);', p.oid :: REGPROC, pg_get_function_identity_arguments(p.oid)), E' ') FROM pg_proc p JOIN pg_namespace ns ON ns.oid = p.pronamespace WHERE ns.nspname = _sch; IF _sql IS NOT NULL THEN EXECUTE _sql; END IF; END $func$ LANGUAGE plpgsql;
sql.function.insertUser=/* Add user */ CREATE OR REPLACE FUNCTION insertUser(set_name TEXT, set_login TEXT, set_password TEXT, set_email TEXT, set_created TIMESTAMP WITH TIME ZONE, set_role TEXT, set_country TEXT, set_city TEXT) RETURNS INTEGER AS $$ DECLARE set_country_id INTEGER; set_city_id INTEGER; BEGIN INSERT INTO countries (name) VALUES (set_country) ON CONFLICT DO NOTHING; INSERT INTO cities (name) VALUES (set_city) ON CONFLICT DO NOTHING; set_country_id := (SELECT countries.id FROM countries WHERE countries.name = set_country); set_city_id := (SELECT cities.id FROM cities WHERE cities.name = set_city); INSERT INTO users (name, login, password, email, created, role, country_id, city_id) VALUES (set_name, set_login, set_password, set_email, set_created, set_role, set_country_id, set_city_id); RETURN (SELECT users.id FROM users WHERE users.login = set_login); END; $$ LANGUAGE plpgsql;
sql.function.updateUser=/* Update user */ CREATE OR REPLACE FUNCTION updateUser(update_id INTEGER, set_name TEXT, set_login TEXT, set_password TEXT, set_email TEXT, set_role TEXT, set_country TEXT, set_city TEXT) RETURNS INTEGER AS $$ DECLARE rows_updated INTEGER; set_country_id INTEGER; set_city_id INTEGER; BEGIN INSERT INTO countries (name) VALUES (set_country) ON CONFLICT DO NOTHING; INSERT INTO cities (name) VALUES (set_city) ON CONFLICT DO NOTHING; set_country_id := (SELECT countries.id FROM countries WHERE countries.name = set_country); set_city_id := (SELECT cities.id FROM cities WHERE cities.name = set_city); UPDATE users SET name = set_name, login = set_login, password = set_password, email = set_email, role = set_role, country_id = set_country_id, city_id = set_city_id WHERE users.id = update_id; GET DIAGNOSTICS rows_updated = ROW_COUNT; RETURN rows_updated; END; $$ LANGUAGE plpgsql;
# Queries to use in application
sql.query.insertUser=/* Query to insert user */ SELECT insertUser(set_name => ?, set_login => ?, set_password => ?, set_email => ?, set_created => ?, set_role => ?, set_country => ?, set_city => ?);
sql.query.updateUserById=/* Query to update user */ SELECT updateUser(update_id => ?, set_name => ?, set_login => ?, set_password => ?, set_email => ?, set_role => ?, set_country => ?, set_city => ?);
sql.query.deleteUserById=/* Query to delete user by id */ DELETE FROM users WHERE users.id = ?;
sql.query.findUserById=/* Query to find user by id */ SELECT users.id, users.name, users.login, users.password, users.email, users.created, users.role, countries.name, cities.name FROM users JOIN countries ON users.country_id = countries.id JOIN cities ON users.city_id = cities.id WHERE users.id = ?;
sql.query.findAllUsers=/* Query to return all users */ SELECT users.id, users.name, users.login, users.password, users.email, users.created, users.role, countries.name, cities.name FROM users JOIN countries ON users.country_id = countries.id JOIN cities ON users.city_id = cities.id ORDER BY users.id;



