# Users database storage settings
db.type=postgresql
db.address=//localhost:5432
db.name=test_db
db.user=tester
db.password=password
# Structural changes
sql.structure.createTables=/* Create all needed tables */ BEGIN; CREATE TABLE IF NOT EXISTS roles ( id SERIAL PRIMARY KEY, name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS countries ( id SERIAL PRIMARY KEY, name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS cities ( id SERIAL PRIMARY KEY, name TEXT UNIQUE ); CREATE TABLE IF NOT EXISTS users ( id SERIAL PRIMARY KEY, name TEXT, login TEXT UNIQUE, password TEXT, email TEXT, created TIMESTAMP WITH TIME ZONE, role_id INTEGER, country_id INTEGER REFERENCES countries (id), city_id INTEGER REFERENCES cities (id) ); COMMIT;
sql.structure.dropTables=/* Drop all existing tables */ DO $$ DECLARE brow RECORD; BEGIN FOR brow IN (SELECT format('DROP TABLE %I CASCADE', tablename) AS table_name FROM pg_tables WHERE schemaname = 'public') LOOP EXECUTE brow.table_name; END LOOP; END; $$
sql.structure.dropFunctions=/* Drop all existing functions */ DO $$ DECLARE brow RECORD; BEGIN FOR brow IN (SELECT format('DROP FUNCTION %I.%I(%s);', nspname, proname, oidvectortypes(proargtypes)) AS func_name FROM pg_proc INNER JOIN pg_namespace ns ON (pg_proc.pronamespace = ns.oid) WHERE ns.nspname = 'public'  order by proname) LOOP EXECUTE brow.func_name; END LOOP; END; $$
# Create database functions
sql.createFunction.insertUser=/* Function to insert user */ CREATE FUNCTION insertUser(_name TEXT, _login TEXT, _password TEXT, _email TEXT, _created TIMESTAMP WITH TIME ZONE, _role TEXT, _country TEXT, _city TEXT) RETURNS INTEGER AS $$ DECLARE _role_id INTEGER; _country_id INTEGER; _city_id INTEGER; BEGIN INSERT INTO countries (name) VALUES (_country) ON CONFLICT DO NOTHING; INSERT INTO cities (name) VALUES (_city) ON CONFLICT DO NOTHING; INSERT INTO roles (name) VALUES (_role) ON CONFLICT DO NOTHING; _role_id := (SELECT roles.id FROM roles WHERE roles.name = _role); _country_id := (SELECT countries.id FROM countries WHERE countries.name = _country); _city_id := (SELECT cities.id FROM cities WHERE cities.name = _city); INSERT INTO users (name, login, password, email, created, role_id, country_id, city_id) VALUES (_name, _login, _password, _email, _created, _role_id, _country_id, _city_id); RETURN (SELECT users.id FROM users WHERE users.login = _login); END; $$ LANGUAGE plpgsql;
sql.createFunction.updateUser=/* Function to update user */ CREATE FUNCTION updateUser(_id    INTEGER, _name TEXT, _login TEXT, _password TEXT, _email TEXT, _role TEXT, _country TEXT, _city TEXT) RETURNS INTEGER AS $$ DECLARE rows_updated INTEGER; _role_id     INTEGER; _country_id  INTEGER; _city_id     INTEGER; BEGIN INSERT INTO roles (name) VALUES (_role) ON CONFLICT DO NOTHING; INSERT INTO countries (name) VALUES (_country) ON CONFLICT DO NOTHING; INSERT INTO cities (name) VALUES (_city) ON CONFLICT DO NOTHING; _role_id := (SELECT roles.id FROM roles WHERE roles.name = _role); _country_id := (SELECT countries.id FROM countries WHERE countries.name = _country); _city_id := (SELECT cities.id FROM cities WHERE cities.name = _city); UPDATE users SET name  = _name, login = _login, password = _password, email = _email, role_id = _role_id, country_id = _country_id, city_id = _city_id WHERE users.id = _id; GET DIAGNOSTICS rows_updated = ROW_COUNT; RETURN rows_updated; END; $$ LANGUAGE plpgsql;
# Queries to use in application
sql.query.insertUser=/* Query to insert user */ SELECT insertUser(_name => ?, _login => ?, _password => ?, _email => ?, _created => ?, _role => ?, _country => ?, _city => ?);
sql.query.updateUser=/* Query to update user, returns number of rows changed */ SELECT updateUser(_id => ?, _name => ?, _login => ?, _password => ?, _email => ?, _role => ?, _country => ?, _city => ?);
sql.query.deleteUserById=/* Query to delete user by id */ DELETE FROM users WHERE users.id = ?;
sql.query.findUserById=/* Query to find user by id */ SELECT users.id, users.name, users.login, users.password, users.email, users.created, roles.name, countries.name, cities.name FROM users JOIN roles ON users.role_id = roles.id JOIN countries ON users.country_id = countries.id JOIN cities ON users.city_id = cities.id WHERE users.id = ?;
sql.query.findAllUsers=/* Query to return all users */ SELECT users.id, users.name, users.login, users.password, users.email, users.created, roles.name, countries.name, cities.name FROM users JOIN roles ON users.role_id = roles.id JOIN countries ON users.country_id = countries.id JOIN cities ON users.city_id = cities.id ORDER BY users.id;



