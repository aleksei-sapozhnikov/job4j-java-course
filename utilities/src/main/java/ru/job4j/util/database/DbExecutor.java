package ru.job4j.util.database;

import ru.job4j.util.function.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.*;

/**
 * Tool to simplify jdbc queries.
 *
 * @author Petr Arsentev (parsentev@yandex.ru), Aleksei Sapozhnikov (vermucht@gmail.com)
 * @version 0.1
 * @since 0.1
 */
public class DbExecutor implements AutoCloseable {
    /**
     * Supplier of Connection object.
     */
    private final Connection connection;
    /**
     * Dispatch for functions filling PreparedStatement with parameters.
     */
    private final Map<Class<?>,
            TriConsumerEx<Integer, PreparedStatement, Object>> fillParamsDispatch = new HashMap<>();
    /**
     * Dispatch for constructions forming value objects from ResultSet.
     */
    private final Map<Class<?>,
            BiFunctionEx<Integer, ResultSet, ObjValue>> getResultDispatch = new HashMap<>();

    /**
     * Constructor.
     *
     * @param connection Connector object.
     */
    public DbExecutor(Connection connection) {
        this.connection = connection;
        this.initFillParamsDispatch();
        this.initGetResultDispatch();
    }

    /**
     * Fills fillParamsDispatch with values.
     */
    private void initFillParamsDispatch() {
        this.fillParamsDispatch.put(Integer.class,
                (index, ps, value) -> ps.setInt(index, (Integer) value));
        this.fillParamsDispatch.put(String.class,
                (index, ps, value) -> ps.setString(index, (String) value));
    }

    /**
     * Fills getResultDispatch with values.
     */
    private void initGetResultDispatch() {
        this.getResultDispatch.put(String.class,
                ((index, res) -> new ObjValue(res.getString(index + 1))));
        this.getResultDispatch.put(Integer.class,
                ((index, res) -> new ObjValue(res.getInt(index + 1))));
    }

    /**
     * For-each statement with index. Gives to consumer value and it's index in given list.
     *
     * @param values   List of values.
     * @param consumer Consumer.
     * @param <T>      Values type.
     * @throws Exception Possible Exception.
     */
    private <T> void forIndex(List<T> values, BiConsumerEx<Integer, T> consumer) throws Exception {
        int index = 0;
        for (T value : values) {
            consumer.accept(index++, value);
        }
    }

    /**
     * Wrapper for routine operations with PreparedStatements.
     * Executes sql query and returns result as Optional.
     * <p>
     * This is the basic, full version of execute() method with all input parameters.
     *
     * @param sql               Query string to form PreparedStatement.
     * @param params            List of parameters to put into the PreparedStatement.
     * @param function          Function to execute on the PreparedStatement.
     * @param autoGeneratedKeys A flag indicating whether auto-generated keys should be returned:
     *                          <tt>Statement.RETURN_GENERATED_KEYS</tt> or
     *                          <tt>Statement.NO_GENERATED_KEYS</tt>
     * @param <R>               Return value type.
     * @return Operation result or <tt>Optional.empty</tt>.
     */
    private <R> Optional<R> execute(String sql, List<Object> params,
                                    FunctionEx<PreparedStatement, R> function, int autoGeneratedKeys) {
        Optional<R> result = Optional.empty();
        try (PreparedStatement statement = this.connection.prepareStatement(sql, autoGeneratedKeys)) {
            this.forIndex(params, (index, value) -> this.fillParamsDispatch
                    .get(value.getClass())
                    .accept(index + 1, statement, value));
            result = Optional.of(function.apply(statement));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    /**
     * Executes sql query and returns result as Optional.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param params   List of parameters to put into the PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     * @param <R>      Return value type.
     * @return Operation result or <tt>Optional.empty</tt>.
     */
    public <R> Optional<R> execute(String sql, List<Object> params,
                                   FunctionEx<PreparedStatement, R> function) {
        return this.execute(sql, params, function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Executes sql query.
     * Doesn't return any result.
     *
     * @param sql               Query string to form PreparedStatement.
     * @param params            List of parameters to put into the PreparedStatement.
     * @param function          Function to execute on the PreparedStatement.
     * @param autoGeneratedKeys A flag indicating whether auto-generated keys should be returned:
     *                          <tt>Statement.RETURN_GENERATED_KEYS</tt> or
     *                          <tt>Statement.NO_GENERATED_KEYS</tt>
     */
    private void execute(String sql, List<Object> params,
                         ConsumerEx<PreparedStatement> function, int autoGeneratedKeys) {
        this.execute(sql, params, ps -> {
                    function.accept(ps);
                    return Optional.empty();
                }, autoGeneratedKeys
        );
    }

    /**
     * Executes sql query.
     * Doesn't return any result.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param params   List of parameters to put into the PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     */
    private void execute(String sql, List<Object> params, ConsumerEx<PreparedStatement> function) {
        this.execute(sql, params, function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Wrapper for routine operations with PreparedStatements.
     * Executes sql query.
     * <p>
     * Doesn't take PreparedStatement parameters.
     * Doesn't return any result.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     */
    public void execute(String sql, ConsumerEx<PreparedStatement> function) {
        this.execute(sql, Collections.emptyList(), function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Executes PreparedStatement.executeQuery and returns
     * map with values obtained from ResultSet.
     * <p>
     * Doesn't return auto-generated keys.
     *
     * @param sql     Query string to form PreparedStatement.
     * @param params  List of parameters to put into the PreparedStatement.
     * @param classes List of classes to get from the ResultQuery.
     */
    public Optional<List<Map<Integer, ObjValue>>> executeQuery(String sql, List<Object> params, List<Class<?>> classes) {
        return this.execute(sql, params, (PreparedStatement ps) -> this.getQueryResult(ps, classes));
    }

    /**
     * Executes PreparedStatement.executeQuery and returns
     * map with values obtained from ResultSet.
     * <p>
     * Doesn't take parameters.
     * Doesn't return auto-generated keys.
     *
     * @param sql     Query string to form PreparedStatement.
     * @param classes List of classes to get from the ResultQuery.
     */
    public Optional<List<Map<Integer, ObjValue>>> executeQuery(String sql, List<Class<?>> classes) {
        return this.execute(sql, Collections.emptyList(), (PreparedStatement ps) -> this.getQueryResult(ps, classes));
    }

    /**
     * Gets group result from the PreparedStatement.
     * Returns list of maps, where maps contain entries: (column index) -> (value obtained).
     *
     * @param pStatement Statement used to execute query.
     * @param classes    List of classes to get from the ResultQuery.
     * @return List of maps, where each map represents result row: (column index) -> (value).
     */
    private List<Map<Integer, ObjValue>> getQueryResult(PreparedStatement pStatement, List<Class<?>> classes) {
        List<Map<Integer, ObjValue>> result = new ArrayList<>();
        try (ResultSet res = pStatement.executeQuery()) {
            while (res.next()) {
                Map<Integer, ObjValue> row = new HashMap<>();
                this.forIndex(classes,
                        (index, clazz) -> row.put(index + 1, this.getResultDispatch.get(clazz).apply(index, res)));
                result.add(row);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    /**
     * Closes resources. Applied in try-with-resources.
     *
     * @throws Exception Possible Exception.
     */
    @Override
    public void close() throws Exception {
        this.connection.close();
    }

    /**
     * Wrapper for value obtained from result set.
     */
    public static class ObjValue {
        /**
         * Value.
         */
        private final Object value;

        /**
         * Constructor. To use only in the executor.
         *
         * @param value Value to assign.
         */
        private ObjValue(Object value) {
            this.value = value;
        }

        /**
         * Returns value as String.
         *
         * @return Value.
         */
        public String asString() {
            if (!(this.value instanceof String)) {
                throw new ClassCastException("Value is not instance of String");
            }
            return (String) this.value;
        }

        /**
         * Returns value as Integer.
         *
         * @return Value.
         */
        public Integer asInteger() {
            if (!(this.value instanceof Integer)) {
                throw new ClassCastException("Value is not instance of Integer");
            }
            return (Integer) this.value;
        }

        /**
         * Equals method.
         *
         * @param o Other object.
         * @return <tt<true</tt> if objects are equal, <tt>false</tt> if not.
         */
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            ObjValue objValue = (ObjValue) o;
            return Objects.equals(value, objValue.value);
        }

        /**
         * Returns hash code();
         *
         * @return Integer hashcode.
         */
        @Override
        public int hashCode() {
            return Objects.hash(value);
        }
    }

}