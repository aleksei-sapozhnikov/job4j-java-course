package ru.job4j.util.database;

import ru.job4j.util.function.*;

import java.sql.*;
import java.util.*;
import java.util.function.Consumer;

/**
 * Tool to simplify jdbc queries.
 *
 * @author Petr Arsentev (parsentev@yandex.ru), Aleksei Sapozhnikov (vermucht@gmail.com)
 * @version 0.1
 * @since 0.1
 */
public class DbExecutor {
    /**
     * Supplier of Connection object.
     */
    private final SupplierEx<Connection> connector;
    /**
     * Handler of throwable objects (exceptions).
     */
    private final Consumer<Throwable> throwableHandler;
    /**
     * Dispatch for functions filling PreparedStatement with parameters.
     */
    private final Map<Class<?>,
            TriConsumerEx<Integer, PreparedStatement, Object>> dispatchFillParams = new HashMap<>();
    /**
     * Dispatch for constructions forming value objects from ResultSet.
     */
    private final Map<Class<?>,
            BiFunctionEx<Integer, ResultSet, ObjValue>> dispatchGetResult = new HashMap<>();

    /**
     * Constructor.
     *
     * @param builder Builder object.
     */
    private DbExecutor(Builder builder) {
        this.connector = builder.connector;
        this.throwableHandler = builder.throwableHandler;
        this.initDispatchFillParams();
        this.initDispatchGetResult();
    }

    /**
     * Fills dispatchFillParams with values.
     */
    private void initDispatchFillParams() {
        this.dispatchFillParams.put(Integer.class,
                (index, ps, value) -> ps.setInt(index, (Integer) value));
        this.dispatchFillParams.put(String.class,
                (index, ps, value) -> ps.setString(index, (String) value));
    }

    /**
     * Fills dispatchGetResult with values.
     */
    private void initDispatchGetResult() {
        this.dispatchGetResult.put(String.class,
                ((index, res) -> new ObjValue(res.getString(index + 1))));
        this.dispatchGetResult.put(Integer.class,
                ((index, res) -> new ObjValue(res.getInt(index + 1))));
    }

    /**
     * For-each statement with index. Gives to consumer value and it's index in given list.
     *
     * @param values   List of values.
     * @param consumer Consumer.
     * @param <T>      Values type.
     * @throws Exception Possible Exception.
     */
    private <T> void forIndex(List<T> values, BiConsumerEx<Integer, T> consumer) throws Exception {
        int index = 0;
        for (T value : values) {
            consumer.accept(index++, value);
        }
    }

    /**
     * Wrapper for routine operations with PreparedStatements.
     * Executes sql query and returns result as Optional.
     * <p>
     * This is the basic, full version of execute() method with all input parameters.
     *
     * @param sql               Query string to form PreparedStatement.
     * @param params            List of parameters to put into the PreparedStatement.
     * @param function          Function to execute on the PreparedStatement.
     * @param autoGeneratedKeys A flag indicating whether auto-generated keys should be returned:
     *                          <tt>Statement.RETURN_GENERATED_KEYS</tt> or
     *                          <tt>Statement.NO_GENERATED_KEYS</tt>
     * @param <R>               Return value type.
     * @return Operation result or <tt>Optional.empty</tt>.
     */
    private <R> Optional<R> execute(String sql, List<Object> params,
                                    FunctionEx<PreparedStatement, R> function, int autoGeneratedKeys
    ) {
        Optional<R> result = Optional.empty();
        try (Connection connection = this.connector.get();
             PreparedStatement statement = connection.prepareStatement(sql, autoGeneratedKeys)) {
            this.forIndex(params,
                    (index, value) -> this.dispatchFillParams
                            .get(value.getClass())
                            .accept(index + 1, statement, value));
            result = Optional.of(function.apply(statement));
        } catch (Exception e) {
            this.throwableHandler.accept(e);
        }
        return result;
    }

    /**
     * Executes sql query and returns result as Optional.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param params   List of parameters to put into the PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     * @param <R>      Return value type.
     * @return Operation result or <tt>Optional.empty</tt>.
     */
    public <R> Optional<R> execute(String sql, List<Object> params,
                                   FunctionEx<PreparedStatement, R> function
    ) {
        return this.execute(sql, params, function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Executes sql query.
     * Doesn't return any result.
     *
     * @param sql               Query string to form PreparedStatement.
     * @param params            List of parameters to put into the PreparedStatement.
     * @param function          Function to execute on the PreparedStatement.
     * @param autoGeneratedKeys A flag indicating whether auto-generated keys should be returned:
     *                          <tt>Statement.RETURN_GENERATED_KEYS</tt> or
     *                          <tt>Statement.NO_GENERATED_KEYS</tt>
     */
    private void execute(String sql, List<Object> params,
                         ConsumerEx<PreparedStatement> function, int autoGeneratedKeys
    ) {
        this.execute(sql, params, ps -> {
                    function.accept(ps);
                    return Optional.empty();
                }, autoGeneratedKeys
        );
    }

    /**
     * Executes sql query.
     * Doesn't return any result.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param params   List of parameters to put into the PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     */
    private void execute(String sql, List<Object> params, ConsumerEx<PreparedStatement> function) {
        this.execute(sql, params, function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Wrapper for routine operations with PreparedStatements.
     * Executes sql query.
     * <p>
     * Doesn't take PreparedStatement parameters.
     * Doesn't return any result.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     */
    public void execute(String sql, ConsumerEx<PreparedStatement> function) {
        this.execute(sql, Collections.emptyList(), function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Executes PreparedStatement.executeQuery and returns
     * map with values obtained from ResultSet.
     * <p>
     * Doesn't return auto-generated keys.
     *
     * @param sql     Query string to form PreparedStatement.
     * @param params  List of parameters to put into the PreparedStatement.
     * @param classes List of classes to get from the ResultQuery.
     */
    public Optional<List<Map<Integer, ObjValue>>> executeQuery(String sql, List<Object> params, List<Class<?>> classes) {
        return this.execute(sql, params, (PreparedStatement ps) -> this.getQueryResult(ps, classes));
    }

    /**
     * Gets group result from the PreparedStatement.
     * Returns list of maps, where maps contain entries: (column index) -> (value obtained).
     *
     * @param pStatement Statement used to execute query.
     * @param classes    List of classes to get from the ResultQuery.
     * @return List of maps, where each map represents result row: (column index) -> (value).
     */
    private List<Map<Integer, ObjValue>> getQueryResult(PreparedStatement pStatement, List<Class<?>> classes) {
        List<Map<Integer, ObjValue>> result = new ArrayList<>();
        try (ResultSet res = pStatement.executeQuery()) {
            while (res.next()) {
                Map<Integer, ObjValue> row = new HashMap<>();
                this.forIndex(classes,
                        (index, clazz) -> row.put(index + 1, this.dispatchGetResult.get(clazz).apply(index, res)));
                result.add(row);
            }
        } catch (Exception e) {
            this.throwableHandler.accept(e);
        }
        return result;
    }

    /**
     * Builder for DbExecutor objects.
     */
    public static class Builder {
        /**
         * Required fields.
         */
        private final SupplierEx<Connection> connector;
        /**
         * Optional fields.
         */
        private Consumer<Throwable> throwableHandler = Throwable::printStackTrace;

        /**
         * Constructor. Takes Required parameters.
         *
         * @param connector Connection object supplier.
         */
        public Builder(SupplierEx<Connection> connector) {
            this.connector = connector;
        }

        /**
         * Sets 'throwableHandler' field value and returns this builder.
         *
         * @param throwableHandler Value to set.
         */
        public Builder setThrowableHandler(Consumer<Throwable> throwableHandler) {
            this.throwableHandler = throwableHandler;
            return this;
        }

        /**
         * Returns new DbExecutor object constructed with this builder.
         *
         * @return New DbExecutor object.
         */
        public DbExecutor build() {
            return new DbExecutor(this);
        }
    }

    /**
     * Wrapper for value obtained from result set.
     */
    public static class ObjValue {
        /**
         * Value.
         */
        private final Object value;

        /**
         * Constructor. To use only in the executor.
         *
         * @param value Value to assign.
         */
        private ObjValue(Object value) {
            this.value = value;
        }

        /**
         * Returns value as String.
         *
         * @return Value.
         */
        public String getString() {
            if (!(this.value instanceof String)) {
                throw new ClassCastException("Value is not instance of String");
            }
            return (String) this.value;
        }

        /**
         * Returns value as Integer.
         *
         * @return Value.
         */
        public Integer getInteger() {
            if (!(this.value instanceof Integer)) {
                throw new ClassCastException("Value is not instance of Integer");
            }
            return (Integer) this.value;
        }

        /**
         * Equals method.
         *
         * @param o Other object.
         * @return <tt<true</tt> if objects are equal, <tt>false</tt> if not.
         */
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            ObjValue objValue = (ObjValue) o;
            return Objects.equals(value, objValue.value);
        }

        /**
         * Returns hash code();
         *
         * @return Integer hashcode.
         */
        @Override
        public int hashCode() {
            return Objects.hash(value);
        }
    }

}